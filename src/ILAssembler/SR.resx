<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="UnexpectedArgument" xml:space="preserve">
    <value>Expected {0} arguments for "{1}".</value>
  </data>
  <data name="UnsupportedElement" xml:space="preserve">
    <value>Language element "{0}" is not supported in this context.</value>
  </data>
  <data name="InvalidArgumentType" xml:space="preserve">
    <value>Expected value to be of type "{0}".</value>
  </data>
  <data name="MissingDeclaringType" xml:space="preserve">
    <value>Unable to determine the declaring type.</value>
  </data>
  <data name="SingleGenericArgumentExpected" xml:space="preserve">
    <value>The modifier type "{0}" expects only a single generic argument.</value>
  </data>
  <data name="TypeNotFound" xml:space="preserve">
    <value>Unable to find type "{0}".</value>
  </data>
  <data name="UnexpectedLocalsArgument" xml:space="preserve">
    <value>Unexpected argument in locals declaration.</value>
  </data>
  <data name="MissingLocalsBody" xml:space="preserve">
    <value>Missing locals declaration body.</value>
  </data>
  <data name="UnexpectedLocalsKeyword" xml:space="preserve">
    <value>Expected either bareword "init" modifier or locals body.</value>
  </data>
  <data name="LocalsAlreadySpecified" xml:space="preserve">
    <value>Locals must be declared only once.</value>
  </data>
  <data name="MaxStackAlreadySpecified" xml:space="preserve">
    <value>Max stack size must be declared only once.</value>
  </data>
  <data name="UnrecognizedOpCode" xml:space="preserve">
    <value>Unrecognized CIL instruction.</value>
  </data>
  <data name="MultipleCatchTypesNotSupported" xml:space="preserve">
    <value>Only one catch type can be specified.</value>
  </data>
  <data name="CannotReadCommandName" xml:space="preserve">
    <value>Unable to determine element name.</value>
  </data>
  <data name="MemberNotFound" xml:space="preserve">
    <value>Unable to resolve signature.</value>
  </data>
  <data name="UndefinedLocal" xml:space="preserve">
    <value>The specified local is not defined.</value>
  </data>
  <data name="InvalidCalliArgument" xml:space="preserve">
    <value>The instruction calli does not take any arguments after the method signature declaration.</value>
  </data>
  <data name="UnknownCallingConvention" xml:space="preserve">
    <value>Expected a calling convention of default, vararg, or unmanaged (cdecl, stdcall, thiscall, or fastcall).</value>
  </data>
  <data name="UnknownUnmanagedCallingConvention" xml:space="preserve">
    <value>Expected an unmanaged calling convention of cdecl, stdcall, thiscall, or fastcall.</value>
  </data>
  <data name="UnexpectedCallingConvention" xml:space="preserve">
    <value>A calling convention was already specified for this call site.</value>
  </data>
  <data name="IncompleteCalli" xml:space="preserve">
    <value>Expected calli signature, e.g. calli unmanaged stdcall { [ReturnType] $_::_([ParameterType]) }</value>
  </data>
  <data name="MissingBranches" xml:space="preserve">
    <value>Expected an array literal of branch names.</value>
  </data>
  <data name="MissingBranchName" xml:space="preserve">
    <value>Expected branch name.</value>
  </data>
  <data name="UnexpectedNode" xml:space="preserve">
    <value>Unexpected element type.</value>
  </data>
  <data name="FieldTypeNotFound" xml:space="preserve">
    <value>Unable to determine field type.</value>
  </data>
  <data name="FieldNameNotFound" xml:space="preserve">
    <value>Unable to determine field name.</value>
  </data>
  <data name="ExpectedFieldSignature" xml:space="preserve">
    <value>Expected field signature declaration, e.g. [FieldType] [DeclaringType]._fieldName</value>
  </data>
  <data name="LocalAlreadyDefined" xml:space="preserve">
    <value>The identifier "{0}" has already been defined.</value>
  </data>
  <data name="ExpectedConstantMemberName" xml:space="preserve">
    <value>Member name must be a constant string value.</value>
  </data>
  <data name="ReturnTypeNotFound" xml:space="preserve">
    <value>Unable to determine return type.</value>
  </data>
  <data name="ExpectedMethodSignature" xml:space="preserve">
    <value>Expected method signature declaration, e.g. [ReturnType] [DeclaringType].MethodName([int] $optionalArgName)</value>
  </data>
  <data name="MissingEndParenthesisInExpression" xml:space="preserve">
    <value>Missing closing ')' in expression.</value>
  </data>
  <data name="InvalidStatementCount" xml:space="preserve">
    <value>Expected only one statement in this signature declaration.</value>
  </data>
  <data name="MissingTypeSpecification" xml:space="preserve">
    <value>Missing type specification.</value>
  </data>
  <data name="MissingSignatureIdentifier" xml:space="preserve">
    <value>Missing signature identifier.</value>
  </data>
  <data name="ExpectedTypeExpression" xml:space="preserve">
    <value>Member expression subject must be a resolvable type expression.</value>
  </data>
  <data name="ByRefNotSupported" xml:space="preserve">
    <value>ByRef types are not supported in this signature kind.</value>
  </data>
  <data name="PinnedNotSupported" xml:space="preserve">
    <value>Pinned types are not supported in this signature kind.</value>
  </data>
  <data name="TypeAlreadySpecified" xml:space="preserve">
    <value>The type must be specified only once.</value>
  </data>
  <data name="ExpectedVariableExpression" xml:space="preserve">
    <value>Expected variable expression but found type expression.</value>
  </data>
  <data name="LocalsModAlreadySpecified" xml:space="preserve">
    <value>The locals modifier "{0}" must be specified only once.</value>
  </data>
  <data name="MissingTryStatementBlock" xml:space="preserve">
    <value>The try statement is missing its statement block.</value>
  </data>
  <data name="MissingExceptionHandler" xml:space="preserve">
    <value>The try statement is missing its catch, filter, finally, or fault statement.</value>
  </data>
  <data name="MissingPrecedingTry" xml:space="preserve">
    <value>The exception handler is missing it's preceding try statement.</value>
  </data>
  <data name="UntypedCatchRequired" xml:space="preserve">
    <value>A catch statement that follows a "filter" statement must be untyped.</value>
  </data>
  <data name="MissingCatchBody" xml:space="preserve">
    <value>The catch statement is missing its type declaration and/or statement block.</value>
  </data>
  <data name="MissingCatchForFilter" xml:space="preserve">
    <value>The preceding filter statement is missing its catch statement.</value>
  </data>
  <data name="MissingExceptionHandlerBody" xml:space="preserve">
    <value>The {0} statement is missing its statement block.</value>
  </data>
  <data name="UnexpectedToken" xml:space="preserve">
    <value>Unexpected token '{0}' in expression or statement.</value>
  </data>
  <data name="MixedExceptionHandlerTypes" xml:space="preserve">
    <value>A finally or fault statement cannot share a try region with catch statements.</value>
  </data>
  <data name="MissingSignatureBody" xml:space="preserve">
    <value>Expected signature body.</value>
  </data>
  <data name="TryStatementNotSupported" xml:space="preserve">
    <value>The PowerShell syntax for try/catch/finally is not supported. Use '.try' instead.</value>
  </data>
  <data name="LabelNotMarked" xml:space="preserve">
    <value>The label '{0}' has not been marked.</value>
  </data>
  <data name="DelegateTypeMissingInvoke" xml:space="preserve">
    <value>The specified delegate type does not have an usable 'Invoke' method.</value>
  </data>
  <data name="InvalidDelegateType" xml:space="preserve">
    <value>The specified delegate type does not inherit from 'System.Delegate'.</value>
  </data>
  <data name="BadImageFormat" xml:space="preserve">
    <value>The CLR reported an error while attempting to create a delegate for this method. See Get-Help about_BadImageFormat for more information.</value>
  </data>
  <data name="FullLanguageRequired" xml:space="preserve">
    <value>This command cannot be invoked in constrained or no language mode.</value>
  </data>
</root>
